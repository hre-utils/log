#!/bin/bash
#
# changelog
#  2021-05-30  :: Copied over from @pid-1/utils/log.sh

#───────────────────────────────────( init )────────────────────────────────────
source $(which hre-lib-import.sh) || exit 255
.import --optional colors

DATAFILE="${XDG_DATA_HOME:-$HOME/.local/share}/hre-utils/log/logfile.txt"

#─────────────────────────────────( functions )─────────────────────────────────

function usage {
cat << EOF
USAGE: ${bwh}$(basename ${BASH_SOURCE[0]})${rst} [--quick ENTRY] [--read NUM]

Commands:
   -h|--help            show this message and exit
   -q|--quick ENTRY     adds entry on CLI without opening editor
   -r|--read  NUM       displays last NUM entries

Description:
   Run \`log\`. A blank entry is opened in vim's insert mode. Type above the line
   to save to a logfile. Minor processing is done:
      1. Newlines and lines beginning with a comment character (#) are stripped
      2. Subsequent lines are intented +19 to properly justify beneath the date
EOF

exit $?
}

#────────────────────────────────────( i/o )────────────────────────────────────
function read_entries {
   local num=$1
   if [[ ! ${num} =~ ^[0-9]+$ ]] ; then
      echo "${rd}◆${rst} Invalid read value \"${br}${num}${rst}\". "
      exit 2
   fi

   local -a forward_lines buffer
   mapfile forward_lines < "$DATAFILE"

   local -i idx=${#forward_lines[@]}
   while [[ $idx -gt 0 ]] && [[ $num -gt 0 ]] ; do
      ((idx--))
      line="${forward_lines[$idx]}"

      if [[ ! "${line}" =~ ^[[:space:]]+ ]] ; then
         ((num--))
      fi

      buffer+=( "$line" )
   done

   local -i idx=$(( ${#buffer[@]} - 1 ))
   while [[ $idx -ge 0 ]] ; do
      echo -n "${buffer[$idx]}"
      ((idx--))
   done
}


function add_entry {
   local tmpfile=$(mktemp --suffix=.txt)

   #────────────────────────────( write tmpfile )───────────────────────────────
   cat <<EOF >"$tmpfile"

#────────────────────────( logfile )─────────────────────────
# Write quick notes, in case you need to refer to them in the
# future. You are already in insert mode. Just start writing.
# Comments, empty lines, and blank newlines will be stripped.
EOF

   #────────────────────────────( edit tmpfile )────────────────────────────────
   # the `|| exit` allows the user to `:cq` without the script continuing.
   vim -c "norm! ggO" -c 'startinsert' -c 'set wrap tw=61 cc=62' ${tmpfile} || exit 0

   #────────────────────────────( parse tmpfile )───────────────────────────────
   today="$(date '+%Y/%b/%d %H:%M')"
   spacer="$(for i in {1..19} ; do printf ' ' ; done)"

   readarray lines < "$tmpfile"
   for idx in "${!lines[@]}" ; do
      line="${lines[$idx]}"

      [[ "${line}" == '' ]] && continue
      [[ "${line}" == $'\n' ]] && continue
      [[ "${line}" =~ ^\ *#.* ]] && continue

      if [[ $idx -eq 0 ]] ; then
         printf "${today}  ${line}" >> ${DATAFILE}
         continue
      else
         printf "${spacer}${line//.*\n+$//}" >> ${DATAFILE}
      fi
   done
}


function find_entries {
   search_pattern="$@"
   echo "NYI"
   exit 1
}


function quick_entry {
   declare -a result
   mapfile entry < <(echo "$@" | tr -s ' ' | sed 's/ /\n/g' )

   lineNR=0
   for word in "${entry[@]//$'\n'/}" ; do
      existing_line_length=${#result[$lineNR]}
      line_plus_word=$(( $existing_line_length + ${#word} ))

      if [[ $((${#result[$lineNR]} + ${#word})) -le 61 ]]
      # Normal case: append word to line, don't prepend space if it's the
      # first word of the line
      then
         if [[ ${#result[$lineNR]} -eq 0 ]] ; then
            result[$lineNR]+="$word"
            #printf "${result[$lineNR]}\n"
         else
            result[$lineNR]+=" $word"
            #printf "${result[$lineNR]}\n"
         fi
      # Length limit reached--word wrap
      else
         ((lineNR=$lineNR+1))
         result[$lineNR]+="$word"
      fi
   done

   today="$(date '+%Y/%b/%d %H:%M')"
   spacer="$(for i in {1..19} ; do printf ' ' ; done)"

   for idx in "${!result[@]}" ; do
      line="${result[$idx]}"

      if [[ $idx -eq 0 ]] ; then
         printf "${today}  ${line}\n" >> ${DATAFILE}
         continue
      elif [[ $idx -eq $((${#result[@]} - 1)) ]] ; then
         printf "${spacer}${line}\n" >> ${DATAFILE}
      else
         printf "${spacer}${line}" >> ${DATAFILE}
      fi
   done
}


#══════════════════════════════════╡ ENGAGE ╞═══════════════════════════════════
case "$1" in
   -h|--help|help)
         usage 0
         ;;

   -r|--read|read)
         shift ; read_entries "$1"
         ;;

   -q|--quick|quick)
         shift ; quick_entry "$@"
         ;;

   -f|--find|find)
         shift ; find_entries "$@"
         ;;

   '')   add_entry
         ;;

   *)    usage 1
         ;;
esac
